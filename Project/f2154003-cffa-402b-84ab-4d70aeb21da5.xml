<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>IF Update THEN &#xD;
	Update_busy:=TRUE;&#xD;
	Counter:=UINT#0;&#xD;
	ec_ena_dis_step:=UINT#0;&#xD;
	moduleType:=UINT#10;&#xD;
	mc_use_unuse_step:= UINT#0;&#xD;
	Error:=false;&#xD;
	Update_Done:=FALSE;&#xD;
	AxisCounter:=UINT#0;&#xD;
	NodeCounter:=UINT#0;&#xD;
	Clear(Error_Event);&#xD;
	No_of_errorEvent:=UINT#0;&#xD;
	&#xD;
	&#xD;
END_IF;&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
IF Update_busy = TRUE and Max_No_of_modules&lt;UINT#101 then&#xD;
	&#xD;
	// loop trough all modules  Modultype  10 = axis group,   20 = axis,  30 = ethercat node,  40 = program&#xD;
&#xD;
		&#xD;
		CASE moduleType of&#xD;
			//****************************************************************************************&#xD;
			10: //Mc axis group enable/disable loop&#xD;
					IF Module_setting[Counter].NoOfAxisGroup &gt; UINT#0 then&#xD;
					&#xD;
					&#xD;
					&#xD;
					temp:=TRUE;&#xD;
					ELSE // no MC axis group&#xD;
						&#xD;
						moduleType:=20; // go further to MX enable/disable&#xD;
					END_IF;&#xD;
			&#xD;
		//***********************************************************************************	&#xD;
			&#xD;
			20: //Mc axis enable/disable loop&#xD;
			&#xD;
			IF no_allow_disable AND NOT Module_setting[Counter].ModuleEnable THEN&#xD;
				// ethercat node enable/disable loop, skip block&#xD;
				moduleType:=30; // ethercat node enable disable&#xD;
				&#xD;
			ELSE  // module disabled during no-disable mode&#xD;
					IF Module_setting[Counter].NoOfAxis &gt; UINT#0 then&#xD;
					&#xD;
									CASE mc_use_unuse_step OF&#xD;
											&#xD;
	    									0: //ini the MC enable FB&#xD;
												mc_change_exe:=false;&#xD;
												IF MC_ChangeAxisUse_FB.Done=FALSE THEN&#xD;
													mc_use_unuse_step:=UINT#1;&#xD;
												END_IF;&#xD;
											&#xD;
			&#xD;
		&#xD;
											1://exe the MC enable FB&#xD;
													mc_change_axis:=Module_setting[Counter].Axis[axisCounter];&#xD;
													if Module_setting[Counter].ModuleEnable = TRUE then // select use axis or not&#xD;
													  				mc_change_use:=_mcUsedAxis;&#xD;
													ELSE&#xD;
																	mc_change_use:=_mcUnusedAxis;&#xD;
													END_IF;&#xD;
													&#xD;
													mc_change_exe:=true;&#xD;
													&#xD;
													//************ FB DONE**************&#xD;
													IF MC_ChangeAxisUse_FB.Done=TRUE AND MC_ChangeAxisUse_FB.Error= FALSE  THEN&#xD;
																mc_change_exe:=FALSE;&#xD;
																mc_use_unuse_step:=UINT#2;&#xD;
													&#xD;
													// error handling if MC axis change not work&#xD;
													ELSIF  MC_ChangeAxisUse_FB.Error= TRUE THEN&#xD;
																Error:= TRUE;&#xD;
																error_mes:= CONCAT(In1:= 'Error when Use/unUse axis No ', In2:=UINT_TO_STRING(mc_change_axis));&#xD;
																StackPush(In:=error_mes, InOut:=Error_Event[0], Size:=UINT#20, Num:=No_of_errorEvent);&#xD;
																mc_change_exe:=FALSE;&#xD;
																mc_use_unuse_step:=UINT#2;&#xD;
													&#xD;
													ELSIF  MC_ChangeAxisUse_FB.CommandAborted= TRUE THEN&#xD;
																Error:= TRUE;&#xD;
																error_mes:= CONCAT(In1:= 'Command aborted when Use/unUse axis No ', In2:=UINT_TO_STRING(mc_change_axis));&#xD;
																StackPush(In:=error_mes, InOut:=Error_Event[0], Size:=UINT#20, Num:=No_of_errorEvent);&#xD;
																mc_change_exe:=FALSE;&#xD;
																mc_use_unuse_step:=UINT#2;&#xD;
													&#xD;
													&#xD;
													END_IF;&#xD;
		&#xD;
											2:  // &#xD;
														IF MC_ChangeAxisUse_FB.Done=FALSE THEN&#xD;
																IF axisCounter&lt;  (Module_setting[Counter].NoOfAxis - UINT#1) then	&#xD;
																	axisCounter:=axisCounter+UINT#1;&#xD;
																	mc_use_unuse_step:=UINT#0; // goto start of enable ect node&#xD;
																	&#xD;
																ELSE&#xD;
																	axisCounter:=UINT#0;&#xD;
																	 mc_use_unuse_step:=UINT#0;&#xD;
																	 moduleType:=UINT#30; // goto Ethercat node enavle/disable&#xD;
																END_IF;	 &#xD;
														END_IF;&#xD;
													&#xD;
	&#xD;
								END_CASE;&#xD;
										&#xD;
										MC_ChangeAxisUse_FB ( 	Axis :=_MC_AX[mc_change_axis], Execute :=mc_change_exe, 	AxisUse :=mc_change_use);&#xD;
																						&#xD;
																							&#xD;
													&#xD;
					&#xD;
					&#xD;
					&#xD;
					&#xD;
					&#xD;
					&#xD;
					&#xD;
					ELSE // no MC axis&#xD;
						// go direct to start stop programs&#xD;
						moduleType:=30; // ethercat node enable disable&#xD;
					END_IF;&#xD;
			END_IF;&#xD;
			&#xD;
			&#xD;
			//**************************************************************************************&#xD;
			&#xD;
			&#xD;
			30: //ethercat node enable/disable loop&#xD;
			&#xD;
			IF no_allow_disable AND NOT Module_setting[Counter].ModuleEnable THEN&#xD;
				// go direct to start stop programs, skip block&#xD;
				moduleType:=40; // go to program start stop&#xD;
				&#xD;
			ELSE // module disabled during no-disable mode&#xD;
				&#xD;
									//NodeCounter:= UINT#0;&#xD;
									IF Module_setting[Counter].NoOfNodes &gt; UINT#0 then&#xD;
									&#xD;
										CASE ec_ena_dis_step OF&#xD;
											&#xD;
	    									0: //ini the EC enable FB&#xD;
												ec_change_exe:=false;&#xD;
												IF EC_ChangeEnableSetting_FB.Done=FALSE THEN&#xD;
													ec_ena_dis_step:=UINT#1;&#xD;
												END_IF;&#xD;
											&#xD;
			&#xD;
		&#xD;
											1://exe the EC enable FB&#xD;
													ec_change_node:=Module_setting[Counter].Nodes[NodeCounter];&#xD;
													ec_change_ena_dis:=Module_setting[Counter].ModuleEnable;&#xD;
													ec_change_exe:=true;&#xD;
													&#xD;
													//************ FB DONE**************&#xD;
													IF EC_ChangeEnableSetting_FB.Done=TRUE AND EC_ChangeEnableSetting_FB.Error= FALSE  THEN&#xD;
																ec_change_exe:=FALSE;&#xD;
																ec_ena_dis_step:=UINT#2;&#xD;
													&#xD;
													&#xD;
														// error handling if Ethercat node enable/disable not work&#xD;
													ELSIF  EC_ChangeEnableSetting_FB.Error= TRUE THEN&#xD;
																Error:= TRUE;&#xD;
																error_mes:= CONCAT(In1:= 'enable/disable ETC node No ', In2:=UINT_TO_STRING(ec_change_node));&#xD;
																StackPush(In:=error_mes, InOut:=Error_Event[0], Size:=UINT#20, Num:=No_of_errorEvent);&#xD;
																ec_change_exe:=FALSE;&#xD;
																ec_ena_dis_step:=UINT#2;&#xD;
													&#xD;
													END_IF;&#xD;
		&#xD;
											2:  // &#xD;
														IF EC_ChangeEnableSetting_FB.Done=FALSE THEN&#xD;
																IF NodeCounter&lt;  (Module_setting[Counter].NoOfNodes - UINT#1) then	&#xD;
																	NodeCounter:=NodeCounter+UINT#1;&#xD;
																	ec_ena_dis_step:=UINT#0; // goto start of enable ect node&#xD;
																	&#xD;
																ELSE&#xD;
																	 NodeCounter:=UINT#0;&#xD;
																	 ec_ena_dis_step:=UINT#0;&#xD;
																	 moduleType:=UINT#40; // goto program start stop&#xD;
																END_IF;	 &#xD;
														END_IF;&#xD;
													&#xD;
	&#xD;
										END_CASE;&#xD;
											EC_ChangeEnableSetting_FB(Execute:=ec_change_exe, NodeAdr:=ec_change_node, IsEnable:=ec_change_ena_dis);&#xD;
									ELSE&#xD;
										moduleType:=40; // goto program start stop&#xD;
									END_IF;&#xD;
			END_IF;&#xD;
			&#xD;
				&#xD;
				//**************************************************************************************************	&#xD;
	&#xD;
			40: //program start/stop  loop&#xD;
					&#xD;
					IF no_allow_disable AND NOT Module_setting[Counter].ModuleEnable THEN&#xD;
						&#xD;
						//module disabled during no-disable mode, skip block&#xD;
						Module_Status[Counter]:=Module_setting[Counter].ModuleEnable;&#xD;
						Counter:=Counter + UINT#1;&#xD;
						moduleType:=UINT#10;&#xD;
						&#xD;
					ELSE&#xD;
						&#xD;
						IF Module_setting[Counter].NoOfprograms &gt; UINT#0 then&#xD;
							ModulesActivatedList[Counter]:=Module_setting[Counter].Modulename;&#xD;
						&#xD;
							// program handling&#xD;
							&#xD;
									CASE prg_ena_dis_step OF&#xD;
											0:&#xD;
												PrgStep:=0;&#xD;
												prg_ena_dis_step:=1;&#xD;
		&#xD;
											1://&#xD;
													if Module_setting[Counter].ModuleEnable = TRUE then // &#xD;
													  				done_startPrg:=PrgStart(PrgName:=Module_setting[Counter].programs[PrgStep]);&#xD;
																	&#xD;
																	IF done_startPrg= TRUE   THEN&#xD;
																				prg_ena_dis_step:=2;&#xD;
																	ELSE		&#xD;
																				Error:= TRUE;&#xD;
																				error_mes:= CONCAT(In1:= 'Error when start programs:   ', In2:=Module_setting[Counter].programs[PrgStep]);&#xD;
																				StackPush(In:=error_mes, InOut:=Error_Event[0], Size:=UINT#20, Num:=No_of_errorEvent);&#xD;
																				prg_ena_dis_step:=2;&#xD;
																	END_IF;&#xD;
													ELSE&#xD;
																	done_stopPrg:=PrgStop(PrgName:=Module_setting[Counter].programs[PrgStep]);&#xD;
																	&#xD;
																	IF done_stopPrg= TRUE   THEN&#xD;
																				prg_ena_dis_step:=2;&#xD;
																	ELSE		&#xD;
																				Error:= TRUE;&#xD;
																				error_mes:= CONCAT(In1:= 'Error when stop programs:   ', In2:=Module_setting[Counter].programs[PrgStep]);&#xD;
																				StackPush(In:=error_mes, InOut:=Error_Event[0], Size:=UINT#20, Num:=No_of_errorEvent);&#xD;
																				prg_ena_dis_step:=2;&#xD;
																	END_IF;&#xD;
																	&#xD;
													END_IF;&#xD;
													&#xD;
												&#xD;
													&#xD;
											2:  // &#xD;
													IF 	PrgStep &lt; Module_setting[Counter].NoOfprograms-1 then&#xD;
														PrgStep:=PrgStep +1;&#xD;
														prg_ena_dis_step:=1;&#xD;
														&#xD;
													ELSE&#xD;
														prg_ena_dis_step:=3;&#xD;
														&#xD;
													END_IF;&#xD;
											3:&#xD;
													prg_ena_dis_step:=0;&#xD;
													Counter:=Counter + UINT#1;	&#xD;
													moduleType:=UINT#10;&#xD;
	&#xD;
										END_CASE;&#xD;
							&#xD;
							Module_Status[Counter]:=Module_setting[Counter].ModuleEnable; // det er får at huske denne linie når alle programmerne er færdige for så er modulet kørt igennem&#xD;
					&#xD;
					&#xD;
						ELSE // if no program to handle&#xD;
								Module_Status[Counter]:=Module_setting[Counter].ModuleEnable;&#xD;
								Counter:=Counter + UINT#1;	&#xD;
								moduleType:=UINT#10;&#xD;
						END_IF;&#xD;
						&#xD;
					END_IF;&#xD;
					&#xD;
					&#xD;
					&#xD;
					&#xD;
						IF Counter&gt;Max_No_of_modules - UINT#1 then&#xD;
								Update_Done :=TRUE;&#xD;
								Update_busy:=FALSE;&#xD;
						END_IF;&#xD;
					//********************************************************************&#xD;
					&#xD;
			END_CASE;&#xD;
			&#xD;
	&#xD;
	&#xD;
					&#xD;
	&#xD;
	&#xD;
	&#xD;
	&#xD;
&#xD;
	&#xD;
END_IF;</Text></StructuredTextModel>